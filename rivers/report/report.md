# Проект "Генератор изображений водоёмов и водотоков"

## Постановка задачи

### Цели и задачи

Планируется создать модель для генерирования изображений водоёмов и водотоков. Также создать классификацию данных объектов по форме, визуализировать и проанализировать результаты. В конце концов, получить опыт. 

### Проектирование системы

В общем модель будет генеративно-состязательной. Структуру системы я придумал сам после просмотра различных моделей нейронных сетей. Даже если это велосипед, делать его самостоятельно интереснее.

1. В качестве истинного значения дискриминатор будет получать класс водоёма или водотока, изображение и вектор изображения;
2. В качестве ложного значения дискриминатор будет получать вектор (шум), класс вектора и изображение, сгенерированное через декодер, полносвязную и свёрточную сети.

![Схема модели](./images/Model.png)

Таким образом, необходимо создать и обучить следующие модели:

1. Вариационный автоэнкодер;
2. Классификатор;
3. Сеть, улучшающая качество изображения;
4. Расширенная генеративно-состязательная сеть.

## Сбор данных

Сбор изображений был произведён с помощью Google Earth Engine. Был использован датасет "JRC Global Surface Water Mapping Layers, v1.3", в частности, частота, с которой вода в каждой точке присутствовала. Также был использован набор данных LSIB 2017 с границами стран.

Фигура границы россии была разделена на шесть частей. Изображения собирались с каждой части по отдельности и были размещены в шести папках. Названия папок субъективно выбирались по какому-то объекту, входящему в площадь части границы. Планируется загрузить изображения со всей площади России. Названия папок были выбраны следующие:

1. Москва. Площадь региона составила 2 525 323 квадратных километров. Собрано 14 075 необработанных изображений.

2. Петербург. Площадь региона составила 1 393 477 квадратных километров.

3. Тюмень/Байкал. Площадь региона составила 3 570 597 квадратных километров.

4. Сургут. Площадь региона составила 3 976 821. Собрано  17 607 необработанных изображений.

5. Лена. Площадь региона составила 3 626 835 квадратных километров.

6. Охотск. Площадь региона составила 1 730 610 квадратных километров.

Суммарно вышло 16 823 663 квадратных километров. Что отличается от того, что говорит интернет: 17.1 million km квадратных.

Были сгенерированы изображения размером 256 на 256 пикселей и разрешением 100м/пиксель. Изображения, находящиеся на границах, имели неподходящий размер. Также большое количество изображений были практически пустыми. Также на некоторых изображениях были заметны артефакты. Также изображения регионов, близких к северу, растянуты по горизонтали. После удаления неподходящих изображений осталось 77 800 изображений. Они были разделены на тренировочную, валидационную и тестовую выборку по 62 240, 7 780 и 7 780 изображений соответственно.

### Скрипт для сбора изображений:

var countries = ee.FeatureCollection("USDOS/LSIB_SIMPLE/2017"),
    water = ee.Image("JRC/GSW1_3/GlobalSurfaceWater"),
    dezhnev_north_box = ee.Geometry.Polygon(
        [[[115.37264142588786, 78.45588887032271],
          [115.37264142588786, 66.30313636189791],
          [193.06795392588788, 66.30313636189791],
          [193.06795392588788, 78.45588887032271]]], null, false),
    dezhnev_south_box = ee.Geometry.Polygon(
        [[[105.69523911164026, 67.4493976081097],
          [105.69523911164026, 40.66346060639304],
          [197.45305161164026, 40.66346060639304],
          [197.45305161164026, 67.4493976081097]]], null, false);

// get country boundary by code
var country_co = 'RS';
var border = countries.filter(ee.Filter.eq('country_co', country_co));
var parts = border.toList(border.size())

// border parts are colored from black to whate to show their order
border.size().evaluate(function(parts_count) {
  for (var i = 0; i < parts_count; i++) {
    var cval = Math.round(255 / parts_count * i);
    var hex = cval.toString(16);
    hex = hex.length == 1 ? "0" + hex : hex;
    Map.addLayer(ee.Feature(parts.get(i)), {color: '#' + hex + hex + hex}, 'border part ' + i)
  }
})

// print area of parts
var areas = parts.map(function(feature) {
  return ee.Feature(feature).area(1).divide(1e6).round()
})
print('Areas of parts in square kilometers:', areas)
print('Total area (square kilometers):', areas.reduce(ee.Reducer.sum()))

// show water occurence within border
var water = water.visualize({bands: ['occurrence'], min: 0, max: 100});
Map.addLayer(water.clip(border), {min: 0, max: 100, palette: ['blue']}, 'water occurrence');

// export images to google drive
function exportRegion(region, name) {
  Export.image.toDrive({
    image: water,
    description: name,
    fileNamePrefix: name,
    folder:'Earth Engine Exports ' + name,
    region: region,
    shardSize: 256,
    fileDimensions: 256,
    scale: 100,
    skipEmptyTiles: true,
    maxPixels: 2e9
  }); 
}

exportRegion(ee.Feature(parts.get(0)), 'moscow')
exportRegion(ee.Feature(parts.get(1)), 'peterburg')
exportRegion(ee.Feature(parts.get(2)), 'baikal/tyumen')
exportRegion(ee.Feature(parts.get(3)), 'surgut')
exportRegion(ee.Feature(parts.get(4)), 'lena')
exportRegion(ee.Feature(parts.get(5)), 'okhotsk')

// that part is too much
var dezhnev_fc = ee.FeatureCollection([parts.get(4)])
var dezhnev_north = dezhnev_north_box.intersection(dezhnev_fc, 1)
var dezhnev_south = dezhnev_south_box.intersection(dezhnev_fc, 1).difference(dezhnev_north_box, 1)
Map.addLayer(dezhnev_north, {color: 'orange'})
Map.addLayer(dezhnev_south, {color: 'purple'})

exportRegion(dezhnev_north, 'dezhnev_north')
exportRegion(dezhnev_south, 'dezhnev_south')

## Создание вариационного автокодировщика

Перед подачей изображений в автокодировщик, их разрешение снижалось до 64 на 64 пикселей. Набор был разделён на тренировочный, валидационный и тестовый наборы с соотношением 80, 10, 10 соответственно.

Архитектура енкодера:

- Входный слой 64 на 64
- Свёрточный слой на 8 каналов, с ядром 3*3, шагом 2, регуляризатором l2=0.01, функцией активации ReLu;
- Свёрточный слой на 8 каналов, с ядром 3*3, шагом 1, регуляризатором l2=0.01, функцией активации ReLu;
- Свёрточный слой на 16 каналов, с ядром 3*3, шагом 2, регуляризатором l2=0.01, функцией активации ReLu;
- Свёрточный слой на 16 каналов, с ядром 3*3, шагом 1, регуляризатором l2=0.01, функцией активации ReLu;
- Свёрточный слой на 32 канала, с ядром 3*3, шагом 2, регуляризатором l2=0.01, функцией активации ReLu;
- Свёрточный слой на 32 канала, с ядром 3*3, шагом 1, регуляризатором l2=0.01, функцией активации ReLu;
- Свёрточный слой на 64 канала, с ядром 3*3, шагом 2, регуляризатором l2=0.01, функцией активации ReLu;
- Свёрточный слой на 64 канала, с ядром 3*3, шагом 1, регуляризатором l2=0.01, функцией активации ReLu;
- Вытягивание в вектор;
- Полносвязный слой с 128 нейронами, регуляризатором l2=0.01, функцией активации ReLu;
- Два слоя по 16 нейронов, оба связанные с предыдущим слоем, отвечающие за математическое ожидание и дисперсию.
- Объединяющий слой, который, используя генератор случайных нормальных величин, вычисляет вектор скрытого слоя.

Архитектура декодера:

- Входной слой на 16 переменных
- Полносвязный слой с 1024 нейронами, регуляризатором l2=0.01, функцией активации ReLu;
- Изменение формы на 4x4x64
- Свёрточный транспонированный слой на 64 канала, с ядром 3*3, шагом 1, регуляризатором l2=0.02, функцией активации ReLu;
- Свёрточный транспонированный слой на 64 канала, с ядром 3*3, шагом 2, регуляризатором l2=0.02, функцией активации ReLu;
- Свёрточный транспонированный слой на 32 канала, с ядром 3*3, шагом 1, регуляризатором l2=0.02, функцией активации ReLu;
- Свёрточный транспонированный слой на 32 канала, с ядром 3*3, шагом 2, регуляризатором l2=0.02, функцией активации ReLu;
- Свёрточный транспонированный слой на 16 каналов, с ядром 3*3, шагом 1, регуляризатором l2=0.02, функцией активации ReLu;
- Свёрточный транспонированный слой на 16 каналов, с ядром 3*3, шагом 2, регуляризатором l2=0.02, функцией активации ReLu;
- Свёрточный транспонированный слой на 8 каналов, с ядром 3*3, шагом 1, регуляризатором l2=0.02, функцией активации ReLu;
- Свёрточный транспонированный слой на 8 каналов, с ядром 3*3, шагом 2, регуляризатором l2=0.02, функцией активации ReLu;
- Свёрточный транспонированный слой на 1 канал, с ядром 3*3, шагом 2, регуляризатором l2=0.02, сигмоидальной функцией активации;

При обучении модели в качестве функции потерь используется сумма потери реконструкции (MSE) и дивергенции Кульбака-Лейблера.

Обучение модели было завершено на эпохе 39.

![Потери при обучении](./images/vae%20losses.png)

![Результаты на валидационном наборе](./images/vae%20validation%20reconstruction.png)

Примеры генерации новых изображений:

![Генерация новых изображений](./images/vae%20generations.png)

## Создание вариационного автокодировщика

## Возникшие вопросы

1. Можно ли использовать синусоиды (такие, как в алгоритме сжатия JPEG) для создания свёрточных слоёв нейронной сети?
2. Что делать с растяжением изображений в Google Earth Engine? При экспорте изображений в районе устья реки Лены, результаты были растянуты по горизонтали.
3. Как вода проходит через желудок?
4. Почему яблоки на деревьях не плесневеют?

## Использованная литература:

- Орельен Жерон Прикладное машинное обучение с помощью Scikit-Learn и TensorFlow;
- Записи конференций Google по Earth Engine: [часть 1](https://www.youtube.com/watch?v=I-wFYm4Hnhg&list=WL&index=11&t=477s), [часть 2](https://www.youtube.com/watch?v=_Ff8_dME2Gc&list=WL&index=10);
- [Курс по обработке изображений от ВШЭ на Степике](https://stepik.org/course/1280);
- [Курс "Нейронные сети на Python. Уроки" на канале SelfEdu](https://youtube.com/playlist?list=PLA0M1Bcd0w8yv0XGiF1wjerjSZVSrYbjh).
